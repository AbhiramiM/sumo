// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: noninteracting.proto

#ifndef PROTOBUF_noninteracting_2eproto__INCLUDED
#define PROTOBUF_noninteracting_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace noninteracting {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_noninteracting_2eproto();
void protobuf_AssignDesc_noninteracting_2eproto();
void protobuf_ShutdownFile_noninteracting_2eproto();

class CMPWlkgTm;
class Edge;
class GetAngle;
class GetPos;
class MSPersonStage_Walking;
class Position;
class SUMOReal;
class SUMOTime;

// ===================================================================

class Position : public ::google::protobuf::Message {
 public:
  Position();
  virtual ~Position();

  Position(const Position& from);

  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Position& default_instance();

  void Swap(Position* other);

  // implements Message ----------------------------------------------

  inline Position* New() const { return New(NULL); }

  Position* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Position& from);
  void MergeFrom(const Position& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Position* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // optional double y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // optional double z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  double z() const;
  void set_z(double value);

  // @@protoc_insertion_point(class_scope:noninteracting.Position)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  double x_;
  double y_;
  double z_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_noninteracting_2eproto();
  friend void protobuf_AssignDesc_noninteracting_2eproto();
  friend void protobuf_ShutdownFile_noninteracting_2eproto();

  void InitAsDefaultInstance();
  static Position* default_instance_;
};
// -------------------------------------------------------------------

class Edge : public ::google::protobuf::Message {
 public:
  Edge();
  virtual ~Edge();

  Edge(const Edge& from);

  inline Edge& operator=(const Edge& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Edge& default_instance();

  void Swap(Edge* other);

  // implements Message ----------------------------------------------

  inline Edge* New() const { return New(NULL); }

  Edge* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Edge& from);
  void MergeFrom(const Edge& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Edge* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string fromJunctionId = 1;
  void clear_fromjunctionid();
  static const int kFromJunctionIdFieldNumber = 1;
  const ::std::string& fromjunctionid() const;
  void set_fromjunctionid(const ::std::string& value);
  void set_fromjunctionid(const char* value);
  void set_fromjunctionid(const char* value, size_t size);
  ::std::string* mutable_fromjunctionid();
  ::std::string* release_fromjunctionid();
  void set_allocated_fromjunctionid(::std::string* fromjunctionid);

  // optional string toJunctionId = 2;
  void clear_tojunctionid();
  static const int kToJunctionIdFieldNumber = 2;
  const ::std::string& tojunctionid() const;
  void set_tojunctionid(const ::std::string& value);
  void set_tojunctionid(const char* value);
  void set_tojunctionid(const char* value, size_t size);
  ::std::string* mutable_tojunctionid();
  ::std::string* release_tojunctionid();
  void set_allocated_tojunctionid(::std::string* tojunctionid);

  // optional double length = 3;
  void clear_length();
  static const int kLengthFieldNumber = 3;
  double length() const;
  void set_length(double value);

  // @@protoc_insertion_point(class_scope:noninteracting.Edge)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr fromjunctionid_;
  ::google::protobuf::internal::ArenaStringPtr tojunctionid_;
  double length_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_noninteracting_2eproto();
  friend void protobuf_AssignDesc_noninteracting_2eproto();
  friend void protobuf_ShutdownFile_noninteracting_2eproto();

  void InitAsDefaultInstance();
  static Edge* default_instance_;
};
// -------------------------------------------------------------------

class SUMOTime : public ::google::protobuf::Message {
 public:
  SUMOTime();
  virtual ~SUMOTime();

  SUMOTime(const SUMOTime& from);

  inline SUMOTime& operator=(const SUMOTime& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SUMOTime& default_instance();

  void Swap(SUMOTime* other);

  // implements Message ----------------------------------------------

  inline SUMOTime* New() const { return New(NULL); }

  SUMOTime* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SUMOTime& from);
  void MergeFrom(const SUMOTime& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SUMOTime* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double sumoTime = 1;
  void clear_sumotime();
  static const int kSumoTimeFieldNumber = 1;
  double sumotime() const;
  void set_sumotime(double value);

  // @@protoc_insertion_point(class_scope:noninteracting.SUMOTime)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  double sumotime_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_noninteracting_2eproto();
  friend void protobuf_AssignDesc_noninteracting_2eproto();
  friend void protobuf_ShutdownFile_noninteracting_2eproto();

  void InitAsDefaultInstance();
  static SUMOTime* default_instance_;
};
// -------------------------------------------------------------------

class SUMOReal : public ::google::protobuf::Message {
 public:
  SUMOReal();
  virtual ~SUMOReal();

  SUMOReal(const SUMOReal& from);

  inline SUMOReal& operator=(const SUMOReal& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SUMOReal& default_instance();

  void Swap(SUMOReal* other);

  // implements Message ----------------------------------------------

  inline SUMOReal* New() const { return New(NULL); }

  SUMOReal* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SUMOReal& from);
  void MergeFrom(const SUMOReal& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SUMOReal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double sumoReal = 1;
  void clear_sumoreal();
  static const int kSumoRealFieldNumber = 1;
  double sumoreal() const;
  void set_sumoreal(double value);

  // @@protoc_insertion_point(class_scope:noninteracting.SUMOReal)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  double sumoreal_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_noninteracting_2eproto();
  friend void protobuf_AssignDesc_noninteracting_2eproto();
  friend void protobuf_ShutdownFile_noninteracting_2eproto();

  void InitAsDefaultInstance();
  static SUMOReal* default_instance_;
};
// -------------------------------------------------------------------

class MSPersonStage_Walking : public ::google::protobuf::Message {
 public:
  MSPersonStage_Walking();
  virtual ~MSPersonStage_Walking();

  MSPersonStage_Walking(const MSPersonStage_Walking& from);

  inline MSPersonStage_Walking& operator=(const MSPersonStage_Walking& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MSPersonStage_Walking& default_instance();

  void Swap(MSPersonStage_Walking* other);

  // implements Message ----------------------------------------------

  inline MSPersonStage_Walking* New() const { return New(NULL); }

  MSPersonStage_Walking* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MSPersonStage_Walking& from);
  void MergeFrom(const MSPersonStage_Walking& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MSPersonStage_Walking* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .noninteracting.Edge edge = 1;
  bool has_edge() const;
  void clear_edge();
  static const int kEdgeFieldNumber = 1;
  const ::noninteracting::Edge& edge() const;
  ::noninteracting::Edge* mutable_edge();
  ::noninteracting::Edge* release_edge();
  void set_allocated_edge(::noninteracting::Edge* edge);

  // optional .noninteracting.Edge nextRouteEdge = 2;
  bool has_nextrouteedge() const;
  void clear_nextrouteedge();
  static const int kNextRouteEdgeFieldNumber = 2;
  const ::noninteracting::Edge& nextrouteedge() const;
  ::noninteracting::Edge* mutable_nextrouteedge();
  ::noninteracting::Edge* release_nextrouteedge();
  void set_allocated_nextrouteedge(::noninteracting::Edge* nextrouteedge);

  // optional double departPos = 3;
  void clear_departpos();
  static const int kDepartPosFieldNumber = 3;
  double departpos() const;
  void set_departpos(double value);

  // optional double arrivalPos = 4;
  void clear_arrivalpos();
  static const int kArrivalPosFieldNumber = 4;
  double arrivalpos() const;
  void set_arrivalpos(double value);

  // optional double maxSpeed = 5;
  void clear_maxspeed();
  static const int kMaxSpeedFieldNumber = 5;
  double maxspeed() const;
  void set_maxspeed(double value);

  // @@protoc_insertion_point(class_scope:noninteracting.MSPersonStage_Walking)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::noninteracting::Edge* edge_;
  ::noninteracting::Edge* nextrouteedge_;
  double departpos_;
  double arrivalpos_;
  double maxspeed_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_noninteracting_2eproto();
  friend void protobuf_AssignDesc_noninteracting_2eproto();
  friend void protobuf_ShutdownFile_noninteracting_2eproto();

  void InitAsDefaultInstance();
  static MSPersonStage_Walking* default_instance_;
};
// -------------------------------------------------------------------

class CMPWlkgTm : public ::google::protobuf::Message {
 public:
  CMPWlkgTm();
  virtual ~CMPWlkgTm();

  CMPWlkgTm(const CMPWlkgTm& from);

  inline CMPWlkgTm& operator=(const CMPWlkgTm& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMPWlkgTm& default_instance();

  void Swap(CMPWlkgTm* other);

  // implements Message ----------------------------------------------

  inline CMPWlkgTm* New() const { return New(NULL); }

  CMPWlkgTm* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMPWlkgTm& from);
  void MergeFrom(const CMPWlkgTm& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CMPWlkgTm* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .noninteracting.Edge edge = 1;
  bool has_edge() const;
  void clear_edge();
  static const int kEdgeFieldNumber = 1;
  const ::noninteracting::Edge& edge() const;
  ::noninteracting::Edge* mutable_edge();
  ::noninteracting::Edge* release_edge();
  void set_allocated_edge(::noninteracting::Edge* edge);

  // optional .noninteracting.MSPersonStage_Walking stage = 2;
  bool has_stage() const;
  void clear_stage();
  static const int kStageFieldNumber = 2;
  const ::noninteracting::MSPersonStage_Walking& stage() const;
  ::noninteracting::MSPersonStage_Walking* mutable_stage();
  ::noninteracting::MSPersonStage_Walking* release_stage();
  void set_allocated_stage(::noninteracting::MSPersonStage_Walking* stage);

  // optional .noninteracting.SUMOTime sumoTime = 3;
  bool has_sumotime() const;
  void clear_sumotime();
  static const int kSumoTimeFieldNumber = 3;
  const ::noninteracting::SUMOTime& sumotime() const;
  ::noninteracting::SUMOTime* mutable_sumotime();
  ::noninteracting::SUMOTime* release_sumotime();
  void set_allocated_sumotime(::noninteracting::SUMOTime* sumotime);

  // @@protoc_insertion_point(class_scope:noninteracting.CMPWlkgTm)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::noninteracting::Edge* edge_;
  ::noninteracting::MSPersonStage_Walking* stage_;
  ::noninteracting::SUMOTime* sumotime_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_noninteracting_2eproto();
  friend void protobuf_AssignDesc_noninteracting_2eproto();
  friend void protobuf_ShutdownFile_noninteracting_2eproto();

  void InitAsDefaultInstance();
  static CMPWlkgTm* default_instance_;
};
// -------------------------------------------------------------------

class GetPos : public ::google::protobuf::Message {
 public:
  GetPos();
  virtual ~GetPos();

  GetPos(const GetPos& from);

  inline GetPos& operator=(const GetPos& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetPos& default_instance();

  void Swap(GetPos* other);

  // implements Message ----------------------------------------------

  inline GetPos* New() const { return New(NULL); }

  GetPos* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetPos& from);
  void MergeFrom(const GetPos& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetPos* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .noninteracting.MSPersonStage_Walking stage = 1;
  bool has_stage() const;
  void clear_stage();
  static const int kStageFieldNumber = 1;
  const ::noninteracting::MSPersonStage_Walking& stage() const;
  ::noninteracting::MSPersonStage_Walking* mutable_stage();
  ::noninteracting::MSPersonStage_Walking* release_stage();
  void set_allocated_stage(::noninteracting::MSPersonStage_Walking* stage);

  // optional .noninteracting.SUMOTime sumoTime = 2;
  bool has_sumotime() const;
  void clear_sumotime();
  static const int kSumoTimeFieldNumber = 2;
  const ::noninteracting::SUMOTime& sumotime() const;
  ::noninteracting::SUMOTime* mutable_sumotime();
  ::noninteracting::SUMOTime* release_sumotime();
  void set_allocated_sumotime(::noninteracting::SUMOTime* sumotime);

  // @@protoc_insertion_point(class_scope:noninteracting.GetPos)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::noninteracting::MSPersonStage_Walking* stage_;
  ::noninteracting::SUMOTime* sumotime_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_noninteracting_2eproto();
  friend void protobuf_AssignDesc_noninteracting_2eproto();
  friend void protobuf_ShutdownFile_noninteracting_2eproto();

  void InitAsDefaultInstance();
  static GetPos* default_instance_;
};
// -------------------------------------------------------------------

class GetAngle : public ::google::protobuf::Message {
 public:
  GetAngle();
  virtual ~GetAngle();

  GetAngle(const GetAngle& from);

  inline GetAngle& operator=(const GetAngle& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetAngle& default_instance();

  void Swap(GetAngle* other);

  // implements Message ----------------------------------------------

  inline GetAngle* New() const { return New(NULL); }

  GetAngle* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetAngle& from);
  void MergeFrom(const GetAngle& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetAngle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .noninteracting.MSPersonStage_Walking stage = 1;
  bool has_stage() const;
  void clear_stage();
  static const int kStageFieldNumber = 1;
  const ::noninteracting::MSPersonStage_Walking& stage() const;
  ::noninteracting::MSPersonStage_Walking* mutable_stage();
  ::noninteracting::MSPersonStage_Walking* release_stage();
  void set_allocated_stage(::noninteracting::MSPersonStage_Walking* stage);

  // optional .noninteracting.SUMOTime sumoTime = 2;
  bool has_sumotime() const;
  void clear_sumotime();
  static const int kSumoTimeFieldNumber = 2;
  const ::noninteracting::SUMOTime& sumotime() const;
  ::noninteracting::SUMOTime* mutable_sumotime();
  ::noninteracting::SUMOTime* release_sumotime();
  void set_allocated_sumotime(::noninteracting::SUMOTime* sumotime);

  // @@protoc_insertion_point(class_scope:noninteracting.GetAngle)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::noninteracting::MSPersonStage_Walking* stage_;
  ::noninteracting::SUMOTime* sumotime_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_noninteracting_2eproto();
  friend void protobuf_AssignDesc_noninteracting_2eproto();
  friend void protobuf_ShutdownFile_noninteracting_2eproto();

  void InitAsDefaultInstance();
  static GetAngle* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Position

// optional double x = 1;
inline void Position::clear_x() {
  x_ = 0;
}
inline double Position::x() const {
  // @@protoc_insertion_point(field_get:noninteracting.Position.x)
  return x_;
}
inline void Position::set_x(double value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:noninteracting.Position.x)
}

// optional double y = 2;
inline void Position::clear_y() {
  y_ = 0;
}
inline double Position::y() const {
  // @@protoc_insertion_point(field_get:noninteracting.Position.y)
  return y_;
}
inline void Position::set_y(double value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:noninteracting.Position.y)
}

// optional double z = 3;
inline void Position::clear_z() {
  z_ = 0;
}
inline double Position::z() const {
  // @@protoc_insertion_point(field_get:noninteracting.Position.z)
  return z_;
}
inline void Position::set_z(double value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:noninteracting.Position.z)
}

// -------------------------------------------------------------------

// Edge

// optional string fromJunctionId = 1;
inline void Edge::clear_fromjunctionid() {
  fromjunctionid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Edge::fromjunctionid() const {
  // @@protoc_insertion_point(field_get:noninteracting.Edge.fromJunctionId)
  return fromjunctionid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Edge::set_fromjunctionid(const ::std::string& value) {
  
  fromjunctionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:noninteracting.Edge.fromJunctionId)
}
inline void Edge::set_fromjunctionid(const char* value) {
  
  fromjunctionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:noninteracting.Edge.fromJunctionId)
}
inline void Edge::set_fromjunctionid(const char* value, size_t size) {
  
  fromjunctionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:noninteracting.Edge.fromJunctionId)
}
inline ::std::string* Edge::mutable_fromjunctionid() {
  
  // @@protoc_insertion_point(field_mutable:noninteracting.Edge.fromJunctionId)
  return fromjunctionid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Edge::release_fromjunctionid() {
  
  return fromjunctionid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Edge::set_allocated_fromjunctionid(::std::string* fromjunctionid) {
  if (fromjunctionid != NULL) {
    
  } else {
    
  }
  fromjunctionid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fromjunctionid);
  // @@protoc_insertion_point(field_set_allocated:noninteracting.Edge.fromJunctionId)
}

// optional string toJunctionId = 2;
inline void Edge::clear_tojunctionid() {
  tojunctionid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Edge::tojunctionid() const {
  // @@protoc_insertion_point(field_get:noninteracting.Edge.toJunctionId)
  return tojunctionid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Edge::set_tojunctionid(const ::std::string& value) {
  
  tojunctionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:noninteracting.Edge.toJunctionId)
}
inline void Edge::set_tojunctionid(const char* value) {
  
  tojunctionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:noninteracting.Edge.toJunctionId)
}
inline void Edge::set_tojunctionid(const char* value, size_t size) {
  
  tojunctionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:noninteracting.Edge.toJunctionId)
}
inline ::std::string* Edge::mutable_tojunctionid() {
  
  // @@protoc_insertion_point(field_mutable:noninteracting.Edge.toJunctionId)
  return tojunctionid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Edge::release_tojunctionid() {
  
  return tojunctionid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Edge::set_allocated_tojunctionid(::std::string* tojunctionid) {
  if (tojunctionid != NULL) {
    
  } else {
    
  }
  tojunctionid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tojunctionid);
  // @@protoc_insertion_point(field_set_allocated:noninteracting.Edge.toJunctionId)
}

// optional double length = 3;
inline void Edge::clear_length() {
  length_ = 0;
}
inline double Edge::length() const {
  // @@protoc_insertion_point(field_get:noninteracting.Edge.length)
  return length_;
}
inline void Edge::set_length(double value) {
  
  length_ = value;
  // @@protoc_insertion_point(field_set:noninteracting.Edge.length)
}

// -------------------------------------------------------------------

// SUMOTime

// optional double sumoTime = 1;
inline void SUMOTime::clear_sumotime() {
  sumotime_ = 0;
}
inline double SUMOTime::sumotime() const {
  // @@protoc_insertion_point(field_get:noninteracting.SUMOTime.sumoTime)
  return sumotime_;
}
inline void SUMOTime::set_sumotime(double value) {
  
  sumotime_ = value;
  // @@protoc_insertion_point(field_set:noninteracting.SUMOTime.sumoTime)
}

// -------------------------------------------------------------------

// SUMOReal

// optional double sumoReal = 1;
inline void SUMOReal::clear_sumoreal() {
  sumoreal_ = 0;
}
inline double SUMOReal::sumoreal() const {
  // @@protoc_insertion_point(field_get:noninteracting.SUMOReal.sumoReal)
  return sumoreal_;
}
inline void SUMOReal::set_sumoreal(double value) {
  
  sumoreal_ = value;
  // @@protoc_insertion_point(field_set:noninteracting.SUMOReal.sumoReal)
}

// -------------------------------------------------------------------

// MSPersonStage_Walking

// optional .noninteracting.Edge edge = 1;
inline bool MSPersonStage_Walking::has_edge() const {
  return !_is_default_instance_ && edge_ != NULL;
}
inline void MSPersonStage_Walking::clear_edge() {
  if (GetArenaNoVirtual() == NULL && edge_ != NULL) delete edge_;
  edge_ = NULL;
}
inline const ::noninteracting::Edge& MSPersonStage_Walking::edge() const {
  // @@protoc_insertion_point(field_get:noninteracting.MSPersonStage_Walking.edge)
  return edge_ != NULL ? *edge_ : *default_instance_->edge_;
}
inline ::noninteracting::Edge* MSPersonStage_Walking::mutable_edge() {
  
  if (edge_ == NULL) {
    edge_ = new ::noninteracting::Edge;
  }
  // @@protoc_insertion_point(field_mutable:noninteracting.MSPersonStage_Walking.edge)
  return edge_;
}
inline ::noninteracting::Edge* MSPersonStage_Walking::release_edge() {
  
  ::noninteracting::Edge* temp = edge_;
  edge_ = NULL;
  return temp;
}
inline void MSPersonStage_Walking::set_allocated_edge(::noninteracting::Edge* edge) {
  delete edge_;
  edge_ = edge;
  if (edge) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:noninteracting.MSPersonStage_Walking.edge)
}

// optional .noninteracting.Edge nextRouteEdge = 2;
inline bool MSPersonStage_Walking::has_nextrouteedge() const {
  return !_is_default_instance_ && nextrouteedge_ != NULL;
}
inline void MSPersonStage_Walking::clear_nextrouteedge() {
  if (GetArenaNoVirtual() == NULL && nextrouteedge_ != NULL) delete nextrouteedge_;
  nextrouteedge_ = NULL;
}
inline const ::noninteracting::Edge& MSPersonStage_Walking::nextrouteedge() const {
  // @@protoc_insertion_point(field_get:noninteracting.MSPersonStage_Walking.nextRouteEdge)
  return nextrouteedge_ != NULL ? *nextrouteedge_ : *default_instance_->nextrouteedge_;
}
inline ::noninteracting::Edge* MSPersonStage_Walking::mutable_nextrouteedge() {
  
  if (nextrouteedge_ == NULL) {
    nextrouteedge_ = new ::noninteracting::Edge;
  }
  // @@protoc_insertion_point(field_mutable:noninteracting.MSPersonStage_Walking.nextRouteEdge)
  return nextrouteedge_;
}
inline ::noninteracting::Edge* MSPersonStage_Walking::release_nextrouteedge() {
  
  ::noninteracting::Edge* temp = nextrouteedge_;
  nextrouteedge_ = NULL;
  return temp;
}
inline void MSPersonStage_Walking::set_allocated_nextrouteedge(::noninteracting::Edge* nextrouteedge) {
  delete nextrouteedge_;
  nextrouteedge_ = nextrouteedge;
  if (nextrouteedge) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:noninteracting.MSPersonStage_Walking.nextRouteEdge)
}

// optional double departPos = 3;
inline void MSPersonStage_Walking::clear_departpos() {
  departpos_ = 0;
}
inline double MSPersonStage_Walking::departpos() const {
  // @@protoc_insertion_point(field_get:noninteracting.MSPersonStage_Walking.departPos)
  return departpos_;
}
inline void MSPersonStage_Walking::set_departpos(double value) {
  
  departpos_ = value;
  // @@protoc_insertion_point(field_set:noninteracting.MSPersonStage_Walking.departPos)
}

// optional double arrivalPos = 4;
inline void MSPersonStage_Walking::clear_arrivalpos() {
  arrivalpos_ = 0;
}
inline double MSPersonStage_Walking::arrivalpos() const {
  // @@protoc_insertion_point(field_get:noninteracting.MSPersonStage_Walking.arrivalPos)
  return arrivalpos_;
}
inline void MSPersonStage_Walking::set_arrivalpos(double value) {
  
  arrivalpos_ = value;
  // @@protoc_insertion_point(field_set:noninteracting.MSPersonStage_Walking.arrivalPos)
}

// optional double maxSpeed = 5;
inline void MSPersonStage_Walking::clear_maxspeed() {
  maxspeed_ = 0;
}
inline double MSPersonStage_Walking::maxspeed() const {
  // @@protoc_insertion_point(field_get:noninteracting.MSPersonStage_Walking.maxSpeed)
  return maxspeed_;
}
inline void MSPersonStage_Walking::set_maxspeed(double value) {
  
  maxspeed_ = value;
  // @@protoc_insertion_point(field_set:noninteracting.MSPersonStage_Walking.maxSpeed)
}

// -------------------------------------------------------------------

// CMPWlkgTm

// optional .noninteracting.Edge edge = 1;
inline bool CMPWlkgTm::has_edge() const {
  return !_is_default_instance_ && edge_ != NULL;
}
inline void CMPWlkgTm::clear_edge() {
  if (GetArenaNoVirtual() == NULL && edge_ != NULL) delete edge_;
  edge_ = NULL;
}
inline const ::noninteracting::Edge& CMPWlkgTm::edge() const {
  // @@protoc_insertion_point(field_get:noninteracting.CMPWlkgTm.edge)
  return edge_ != NULL ? *edge_ : *default_instance_->edge_;
}
inline ::noninteracting::Edge* CMPWlkgTm::mutable_edge() {
  
  if (edge_ == NULL) {
    edge_ = new ::noninteracting::Edge;
  }
  // @@protoc_insertion_point(field_mutable:noninteracting.CMPWlkgTm.edge)
  return edge_;
}
inline ::noninteracting::Edge* CMPWlkgTm::release_edge() {
  
  ::noninteracting::Edge* temp = edge_;
  edge_ = NULL;
  return temp;
}
inline void CMPWlkgTm::set_allocated_edge(::noninteracting::Edge* edge) {
  delete edge_;
  edge_ = edge;
  if (edge) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:noninteracting.CMPWlkgTm.edge)
}

// optional .noninteracting.MSPersonStage_Walking stage = 2;
inline bool CMPWlkgTm::has_stage() const {
  return !_is_default_instance_ && stage_ != NULL;
}
inline void CMPWlkgTm::clear_stage() {
  if (GetArenaNoVirtual() == NULL && stage_ != NULL) delete stage_;
  stage_ = NULL;
}
inline const ::noninteracting::MSPersonStage_Walking& CMPWlkgTm::stage() const {
  // @@protoc_insertion_point(field_get:noninteracting.CMPWlkgTm.stage)
  return stage_ != NULL ? *stage_ : *default_instance_->stage_;
}
inline ::noninteracting::MSPersonStage_Walking* CMPWlkgTm::mutable_stage() {
  
  if (stage_ == NULL) {
    stage_ = new ::noninteracting::MSPersonStage_Walking;
  }
  // @@protoc_insertion_point(field_mutable:noninteracting.CMPWlkgTm.stage)
  return stage_;
}
inline ::noninteracting::MSPersonStage_Walking* CMPWlkgTm::release_stage() {
  
  ::noninteracting::MSPersonStage_Walking* temp = stage_;
  stage_ = NULL;
  return temp;
}
inline void CMPWlkgTm::set_allocated_stage(::noninteracting::MSPersonStage_Walking* stage) {
  delete stage_;
  stage_ = stage;
  if (stage) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:noninteracting.CMPWlkgTm.stage)
}

// optional .noninteracting.SUMOTime sumoTime = 3;
inline bool CMPWlkgTm::has_sumotime() const {
  return !_is_default_instance_ && sumotime_ != NULL;
}
inline void CMPWlkgTm::clear_sumotime() {
  if (GetArenaNoVirtual() == NULL && sumotime_ != NULL) delete sumotime_;
  sumotime_ = NULL;
}
inline const ::noninteracting::SUMOTime& CMPWlkgTm::sumotime() const {
  // @@protoc_insertion_point(field_get:noninteracting.CMPWlkgTm.sumoTime)
  return sumotime_ != NULL ? *sumotime_ : *default_instance_->sumotime_;
}
inline ::noninteracting::SUMOTime* CMPWlkgTm::mutable_sumotime() {
  
  if (sumotime_ == NULL) {
    sumotime_ = new ::noninteracting::SUMOTime;
  }
  // @@protoc_insertion_point(field_mutable:noninteracting.CMPWlkgTm.sumoTime)
  return sumotime_;
}
inline ::noninteracting::SUMOTime* CMPWlkgTm::release_sumotime() {
  
  ::noninteracting::SUMOTime* temp = sumotime_;
  sumotime_ = NULL;
  return temp;
}
inline void CMPWlkgTm::set_allocated_sumotime(::noninteracting::SUMOTime* sumotime) {
  delete sumotime_;
  sumotime_ = sumotime;
  if (sumotime) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:noninteracting.CMPWlkgTm.sumoTime)
}

// -------------------------------------------------------------------

// GetPos

// optional .noninteracting.MSPersonStage_Walking stage = 1;
inline bool GetPos::has_stage() const {
  return !_is_default_instance_ && stage_ != NULL;
}
inline void GetPos::clear_stage() {
  if (GetArenaNoVirtual() == NULL && stage_ != NULL) delete stage_;
  stage_ = NULL;
}
inline const ::noninteracting::MSPersonStage_Walking& GetPos::stage() const {
  // @@protoc_insertion_point(field_get:noninteracting.GetPos.stage)
  return stage_ != NULL ? *stage_ : *default_instance_->stage_;
}
inline ::noninteracting::MSPersonStage_Walking* GetPos::mutable_stage() {
  
  if (stage_ == NULL) {
    stage_ = new ::noninteracting::MSPersonStage_Walking;
  }
  // @@protoc_insertion_point(field_mutable:noninteracting.GetPos.stage)
  return stage_;
}
inline ::noninteracting::MSPersonStage_Walking* GetPos::release_stage() {
  
  ::noninteracting::MSPersonStage_Walking* temp = stage_;
  stage_ = NULL;
  return temp;
}
inline void GetPos::set_allocated_stage(::noninteracting::MSPersonStage_Walking* stage) {
  delete stage_;
  stage_ = stage;
  if (stage) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:noninteracting.GetPos.stage)
}

// optional .noninteracting.SUMOTime sumoTime = 2;
inline bool GetPos::has_sumotime() const {
  return !_is_default_instance_ && sumotime_ != NULL;
}
inline void GetPos::clear_sumotime() {
  if (GetArenaNoVirtual() == NULL && sumotime_ != NULL) delete sumotime_;
  sumotime_ = NULL;
}
inline const ::noninteracting::SUMOTime& GetPos::sumotime() const {
  // @@protoc_insertion_point(field_get:noninteracting.GetPos.sumoTime)
  return sumotime_ != NULL ? *sumotime_ : *default_instance_->sumotime_;
}
inline ::noninteracting::SUMOTime* GetPos::mutable_sumotime() {
  
  if (sumotime_ == NULL) {
    sumotime_ = new ::noninteracting::SUMOTime;
  }
  // @@protoc_insertion_point(field_mutable:noninteracting.GetPos.sumoTime)
  return sumotime_;
}
inline ::noninteracting::SUMOTime* GetPos::release_sumotime() {
  
  ::noninteracting::SUMOTime* temp = sumotime_;
  sumotime_ = NULL;
  return temp;
}
inline void GetPos::set_allocated_sumotime(::noninteracting::SUMOTime* sumotime) {
  delete sumotime_;
  sumotime_ = sumotime;
  if (sumotime) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:noninteracting.GetPos.sumoTime)
}

// -------------------------------------------------------------------

// GetAngle

// optional .noninteracting.MSPersonStage_Walking stage = 1;
inline bool GetAngle::has_stage() const {
  return !_is_default_instance_ && stage_ != NULL;
}
inline void GetAngle::clear_stage() {
  if (GetArenaNoVirtual() == NULL && stage_ != NULL) delete stage_;
  stage_ = NULL;
}
inline const ::noninteracting::MSPersonStage_Walking& GetAngle::stage() const {
  // @@protoc_insertion_point(field_get:noninteracting.GetAngle.stage)
  return stage_ != NULL ? *stage_ : *default_instance_->stage_;
}
inline ::noninteracting::MSPersonStage_Walking* GetAngle::mutable_stage() {
  
  if (stage_ == NULL) {
    stage_ = new ::noninteracting::MSPersonStage_Walking;
  }
  // @@protoc_insertion_point(field_mutable:noninteracting.GetAngle.stage)
  return stage_;
}
inline ::noninteracting::MSPersonStage_Walking* GetAngle::release_stage() {
  
  ::noninteracting::MSPersonStage_Walking* temp = stage_;
  stage_ = NULL;
  return temp;
}
inline void GetAngle::set_allocated_stage(::noninteracting::MSPersonStage_Walking* stage) {
  delete stage_;
  stage_ = stage;
  if (stage) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:noninteracting.GetAngle.stage)
}

// optional .noninteracting.SUMOTime sumoTime = 2;
inline bool GetAngle::has_sumotime() const {
  return !_is_default_instance_ && sumotime_ != NULL;
}
inline void GetAngle::clear_sumotime() {
  if (GetArenaNoVirtual() == NULL && sumotime_ != NULL) delete sumotime_;
  sumotime_ = NULL;
}
inline const ::noninteracting::SUMOTime& GetAngle::sumotime() const {
  // @@protoc_insertion_point(field_get:noninteracting.GetAngle.sumoTime)
  return sumotime_ != NULL ? *sumotime_ : *default_instance_->sumotime_;
}
inline ::noninteracting::SUMOTime* GetAngle::mutable_sumotime() {
  
  if (sumotime_ == NULL) {
    sumotime_ = new ::noninteracting::SUMOTime;
  }
  // @@protoc_insertion_point(field_mutable:noninteracting.GetAngle.sumoTime)
  return sumotime_;
}
inline ::noninteracting::SUMOTime* GetAngle::release_sumotime() {
  
  ::noninteracting::SUMOTime* temp = sumotime_;
  sumotime_ = NULL;
  return temp;
}
inline void GetAngle::set_allocated_sumotime(::noninteracting::SUMOTime* sumotime) {
  delete sumotime_;
  sumotime_ = sumotime;
  if (sumotime) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:noninteracting.GetAngle.sumoTime)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace noninteracting

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_noninteracting_2eproto__INCLUDED
